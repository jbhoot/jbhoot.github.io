*,
*::before,
*::after {
    box-sizing: border-box;
    padding: 0;
    margin: 0;
}

:root {
    /*Ref: https://every-layout.dev/rudiments/modular-scale/*/
    /*See https://type-scale.com and https://www.modularscale.com/*/
    /*to play with other values.*/
    --base-size: 1rem;
    --ratio: 1.25;
    --measure: 60ch;
    line-height: 1.5;

    --s-4: calc(var(--s-3) / var(--ratio));
    --s-3: calc(var(--s-2) / var(--ratio));
    --s-2: calc(var(--s-1) / var(--ratio));
    --s-1: calc(var(--s0) / var(--ratio));
    --s0: var(--base-size);
    --s1: calc(var(--s0) * var(--ratio));
    --s2: calc(var(--s1) * var(--ratio));
    --s3: calc(var(--s2) * var(--ratio));
    --s4: calc(var(--s3) * var(--ratio));

    --padding-large: calc(var(--s0) + 2vw);
    --padding: calc(var(--s0) + 0.25vw);

    --border-thin: 1px;

    --border-dark: black;
    --border-light: #e2e2e2;

    --border-radius: 4px;

    --font-serif: "Gentium Book Plus", Georgia, serif;
    --font-sans: "PT Sans", Overpass, sans-serif;
    --font-monospaced-sans: "Droid Sans Mono SW", "Droid Sans Mono", "Roboto Mono", "Source Code Pro", "Liberation Mono", Consolas, Monaco, "Fantasque Sans Mono", "DejaVu Sans Mono", Menlo, monospace;
    --font-monospaced-serif: "Courier Screenplay", "Final Draft Heavy", "PT Mono", "Latin Modern Mono", "Courier Prime", Courier, monospace;
}

html {
    block-size: 100%;
    display: flex;
    flex-direction: column;
}

body {
    flex: 1;
    font-family: var(--font-sans);

    /***
     Increase the base font-size to --s1.

     --s0 = 1rem is too small.

     In case of (--s0 + Xvw),  0.25vw or 0.5vw values are too small on mobile devices to add anything to the tiny 1rem.
        But 1vw is so large on a desktop screen that text becomes huge.

     (--s0 + Xvh) might be a better approach than (--s0 + Xvw) because 0.5vh is neither too small on mobile device, nor too large on desktop screen. But I am not sure of any side-effects. But there don't seem to be any because people don't play around with viewport height as much as they do with the viewport width. In any case, the minimum size fonts can shrink to is 1rem, but at least we get a much better default from it than from (--s0 + Xvw).

     But all this mental gymnastics led me to wonder what the hell do I care about scaling the fonts in accordance with the viewport size, as long as the base font size is large enough on all screens? So for now I have resorted to --s1 as the base font-size.

     Updating --s0 = 1rem * module scale does not make sense because the default --s0 would become too large for spacing purposes.
     ***/
    font-size: var(--s1);
}

* {
    max-inline-size: var(--measure);
}

/* Make every img responsive by default.
 * As recommended by Every Layout - The Frame */
img {
    max-inline-size: 100%;
}

/*
The point of using measure is to limit each column of *content* to a readable length.
There might as well be multiple such columns horizontally.
Each column length ideally is equal to the value of the measure. ￼
So the exceptions to the rule that applies measure should be those elements which could be used to lay out horizontal columns of content. ￼
 */
html,
body,
div {
    max-inline-size: none;
}

body * + * {
    margin-block-start: 1em;
}

hgroup > * + * {
    margin-block-start: 2px;
}

h1, h2, h3, h4, h5, h6 {
    font-family: var(--font-serif);
}

h1,
h2,
h3 {
    line-height: 1.25;
}

h1 {
    font-size: var(--s4);
}

h2 {
    font-size: var(--s3);
}

h3 {
    font-size: var(--s2);
}

h4, h5, h6 {
    font-size: var(--s1);
}

caption,
figcaption {
    font-family: var(--font-sans);
    font-size: 0.9em;
    font-style: italic;
    margin-block-start: 0;
}

caption {
    text-align: left;
    caption-side: bottom;
}

:is(figcaption, caption) code {
    font-style: normal;
}

code {
    margin-inline: 4px;
    font-family: var(--font-monospaced-sans);
    font-size: 0.9em;
    outline: 2px solid #efde72;
    outline-offset: 2px;
    background-color: #fff4b0;
}

pre {
    /* pre max-width computes to be wider than other tags because by default it uses monospaced font-family, thus causing the --measure=60ch to compute a wider size. */
    /* Set the font-family to serif to set its measure similar to other tags. */
    /* font-family: var(--font-serif); */

    outline: 1px solid var(--border-light);
    padding: var(--padding);
    color: black;
    overflow: auto;
}

pre:has(> code) {
    outline: 2px solid #efde72;
    background-color: #fff4b0;
}

pre > code {
    outline: none;
    background-color: inherit;
}

img {
    outline: 1px solid var(--border-light);
}

ins {
    text-decoration: none;
    background-color: rgba(0, 128, 0, 0.2);
    padding: 0 4px 0 0;
}

ins::before {
    content: "+ " attr(datetime);
    background-color: green;
    color: white;
    padding: 0 4px 0 4px;
}

table,
th,
td {
    border-collapse: collapse;
}

th,
td {
    border: 1px solid var(--border-dark);
    padding: var(--s-2) var(--s-1);
    text-align: left;
}

tr:hover {
    background-color: #f0f0f0;
}

a {
    text-decoration-style: solid;
    text-decoration-thickness: 1px;
    text-underline-offset: 0.25em;
    text-decoration-skip-ink: none;
}

a:hover {
    text-decoration-style: wavy;
}

ul, ol {
    margin-inline-start: 1em;
}

nav ul {
    margin-inline-start: 0;
    list-style: none;
}

aside {
    color: gray;
    border: 1px dashed gray;
    padding: var(--s0);
}

aside::before {
    display: block;
    content: "ASIDE";
    margin-bottom: var(--s0);
    text-decoration: underline;
}

main {
    background-color: #fbf4e9;
}

blockquote {
    border-inline-start: 2px solid #0097db;
    padding-inline-start: var(--s0);
    font-style: italic;
}

.no-show {
    display: none;
}

@media print {
    main {
        padding: 0 !important;
    }

    .no-print, .no-print * {
        display: none !important;
    }
}