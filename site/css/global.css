*,
*::before,
*::after {
    box-sizing: border-box;
    padding: 0;
    margin: 0;
}

:root {
    /*Ref: https://every-layout.dev/rudiments/modular-scale/*/
    /*See https://type-scale.com and https://www.modularscale.com/*/
    /*to play with other values.*/
    --base-size: 1rem;
    --ratio: 1.125;
    --measure: 60ch;
    line-height: 1.50;

    --s-6: calc(var(--s-5) / var(--ratio));
    --s-5: calc(var(--s-4) / var(--ratio));
    --s-4: calc(var(--s-3) / var(--ratio));
    --s-3: calc(var(--s-2) / var(--ratio));
    --s-2: calc(var(--s-1) / var(--ratio));
    --s-1: calc(var(--s0) / var(--ratio));
    --s0: var(--base-size);
    --s1: calc(var(--s0) * var(--ratio));
    --s2: calc(var(--s1) * var(--ratio));
    --s3: calc(var(--s2) * var(--ratio));
    --s4: calc(var(--s3) * var(--ratio));
    --s5: calc(var(--s4) * var(--ratio));
    --s6: calc(var(--s5) * var(--ratio));

    --padding-large: calc(var(--s0) + 2vw);
    --padding: calc(var(--s0) + 0.25vw);

    --border-thin: 1px;

    --border-dark: black;
    --border-light: #e2e2e2;

    --border-radius: 4px;

    --font-sans: "Atkinson Hyperlegible", "Droid Sans", "Noto Sans", "IBM Plex Sans", "PT Sans", sans-serif;
    --font-serif: "Droid Serif", "Noto Serif", serif;
    --font-monospaced-sans: "Source Code Pro", "Droid Sans Mono SW", "Droid Sans Mono", "DejaVu Sans Mono", Menlo, "Roboto Mono", monospace;
    --font-monospaced-serif: "Courier Screenplay", "Final Draft Heavy", "PT Mono", "Latin Modern Mono", "Courier Prime", Courier, monospace;
}

html {
    block-size: 100%;
    display: flex;
    flex-direction: column;
}

body {
    flex: 1;
    font-family: var(--font-sans);

    /***
     Increase the base font-size to --s1.

     --s0 = 1rem is too small.

     In case of (--s0 + Xvw),  0.25vw or 0.5vw values are too small on mobile devices to add anything to the tiny 1rem.
        But 1vw is so large on a desktop screen that text becomes huge.

     (--s0 + Xvh) might be a better approach than (--s0 + Xvw) because 0.5vh is neither too small on mobile device, nor too large on desktop screen. But I am not sure of any side-effects. But there don't seem to be any because people don't play around with viewport height as much as they do with the viewport width. In any case, the minimum size fonts can shrink to is 1rem, but at least we get a much better default from it than from (--s0 + Xvw).

     But all this mental gymnastics led me to wonder what the hell do I care about scaling the fonts in accordance with the viewport size, as long as the base font size is large enough on all screens? So for now I have resorted to --s1 as the base font-size.

     Updating --s0 = 1rem * module scale does not make sense because the default --s0 would become too large for spacing purposes.
     ***/
    font-size: var(--s1);
    background-color: #fbf4e9;
}

* {
    max-inline-size: var(--measure);
}

/* Make every img responsive by default.
 * As recommended by Every Layout - The Frame */
img {
    max-inline-size: 100%;
}

/*
The point of using measure is to limit each column of *content* to a readable length.
There might as well be multiple such columns horizontally.
Each column length ideally is equal to the value of the measure. ￼
So the exceptions to the rule that applies measure should be those elements which could be used to lay out horizontal columns of content. ￼
 */
html,
body,
main,
div {
    max-inline-size: none;
}

body * + * {
    margin-block-start: var(--s0);
}

hgroup > * + * {
    margin-block-start: var(--s-6);
}

hgroup p {
    color: #5b5a5a;
    /* font-size: 0.9em; */
}

h1, h2, h3, h4, h5, h6 {
    font-family: var(--font-sans);
    /* line-height: 1.25; */
}

h1 {
    font-size: var(--s5);
}

h2 {
    font-size: var(--s4);
}

h3 {
    font-size: var(--s3);
}

h4 {
    font-size: var(--s2);
}

h5, h6 {
    font-size: var(--s1);
}

caption,
figcaption {
    font-family: var(--font-sans);
    font-size: 0.9em;
    font-style: italic;
    margin-block-start: 0;
}

caption {
    text-align: left;
    caption-side: bottom;
}

:is(figcaption, caption) code {
    font-style: normal;
}

code {
    font-family: var(--font-monospaced-sans);
    font-weight: normal;
    font-size: 0.9em;
    color: green;
}

:is(h1, h2, h3, h4, h5, h6) > code {
    font-size: 0.8em;
}

pre {
    /* max-inline-size of <pre> computes to be wider than other tags because it uses monospaced font-family by default, thus causing the --measure=60ch to compute a wider size.
     * Various approaches to tackle this are:
     * 1. Set the font-family to serif to set its measure similar to other tags.
     *    font-family: var(--font-serif);
     *    But code become (subjectively) illegible to an extent.
     * 2. Decrease the max-inline-size of <pre> a bit.
     *    max-inline-size: calc(var(--measure) * 0.9);
     *    But <60ch is too narrow for code snippets The effort of scrolling to see a line of code increases.
     * 3. Decrease the font-size so that max-inline-size reduces by itself.
     *    font-size: 0.9em;
     *    But code snippets become small and a bit hard to read.
     * 4. Let the width consistency go to hell. Size the width of <pre> to a proper 75-80ch.
     *    This is in accordance with the line width of 80 chars used by editors and formatters.
     *    max-inline-size: 80ch;
     *    In order to alleviate the inconsistent widths of normal content and <pre> content,
     *    increase the styling contrast between the two.
     */
    max-inline-size: 75ch;
    background-color: black;
    color: #4AF626;
    overflow: auto;
    padding: 10px;
}

pre > code {
    color: #4AF626;
}

img {
    outline: 1px solid var(--border-light);
}

ins {
    text-decoration: none;
    background-color: rgba(0, 128, 0, 0.2);
    padding: 0 4px 0 0;
}

ins::before {
    content: "+ " attr(datetime);
    background-color: green;
    color: white;
    padding: 0 4px 0 4px;
}

table,
th,
td {
    border-collapse: collapse;
}

th,
td {
    border: 1px solid var(--border-dark);
    padding: var(--s-2) var(--s-1);
    text-align: left;
}

tr:hover {
    background-color: #f0f0f0;
}

a {
    text-decoration-style: solid;
    text-decoration-thickness: 1px;
    text-underline-offset: 0.25em;
    text-decoration-skip-ink: none;
}

a:hover {
    text-decoration-style: wavy;
}

ul, ol {
    /* W3C standard specifies a default padding-inline-start (not margin-inline-start) of 40px for ul and ol.
     * https://html.spec.whatwg.org/multipage/rendering.html#lists
     * So we stick to padding, only change its value.
     */
    padding-inline-start: 2em;
}

ol {
    list-style-type: decimal;
}

ol ol {
    list-style-type: lower-alpha;
}

ol ol ol {
    list-style-type: lower-roman;
}

ul {
    list-style-type: disc;
}

ul ul {
    list-style-type: circle;
}

ul ul ul {
    list-style-type: square;
}

nav ul {
    padding-inline-start: 0;
    list-style: none;
}

aside {
    color: gray;
    border: 1px dashed gray;
    padding: var(--s0);
}

aside::before {
    display: block;
    content: "ASIDE";
    margin-bottom: var(--s0);
    text-decoration: underline;
}

main {
    background-color: #fbf4e9;
}

blockquote {
    border-inline-start: 2px solid #0097db;
    padding-inline-start: var(--s0);
    font-style: italic;
}

.no-show {
    display: none;
}

@media print {
    main {
        padding: 0 !important;
    }

    .no-print, .no-print * {
        display: none !important;
    }
}
