<hgroup>
<h1>Notes on/from Effective Scala</h1>
</hgroup>

<h2>Elements of a Program</h2>

<h3>Value (or Data in this context)</h3>

<p>A value is the representation of some entity that can be manipulated by a program.</p>

<p>Value is the most abstract definition here, but it is made concrete by subsequent definitions.</p>

<h3>Literal</h3>

<p>A literal is a text representation of a value in source code.</p>

<ul>
<li><code>1</code> is an integer literal</li>
<li><code>"1"</code> is a string literal</li>
<li><code>(x) => x * x</code> is a <strong>function literal</strong> aka anonymous function in JavaScript</li>
<li><code>{id: 1, (x) => x * x}</code> is an <strong>object literal</strong> in JavaScript, etc.</li>
</ul>

<h3>(Data) Type</h3>

<p>A data type (or simply type) is a collection of data values.</p>

<p>A type is usually specified by a set of possible values, and a set of allowed <strong>operations</strong> on these
values.</p>

<p>The members of a type are the values of that type.</p>

<h3>Expression</h3>

<p>An expression is a syntactic entity that can evaluate to a value.</p>

<p>An expression combines literals, constants,
variables, and expressions, <strong>by applying operations</strong> (functions, operators, methods) on them.</p>

<ul>
<li><code>1</code> is an integer literal that is also a simple expression that evaluates to value <code>1</code>. Value
<code>1</code> belongs to type <code>Integer</code>.
</li>
<li><code>"Alice" + " Wonderland"</code> is an expression that combines two string literals by applying the operation
<code>+</code> on
them. Literal <code>"Alice"</code> represents the value <code>Alice</code>. The value <code>Alice</code> belongs to type
<code>String</code>. The operation <code>+</code> is an operator/method defined on type <code>String</code> and can be applied on literals, constants, variables that represent a value of type <code>String</code>.
</li>
<li><code>("Alice" + " Wonderland").toUpperCase</code> is an expression in which operation <code>toUpperCase</code> is
applied on the expression <code>"Alice" + " Wonderland"</code>. The expression <code>"Alice" + " Wonderland"</code> evaluates to a value <code>Alice Wonderland</code> of type <code>String</code>. The operation <code>toUpperCase</code> is a method defined on type <code>String</code> and can be applied on literals, constants, variables that represent a value of type <code>String</code>.
</li>
</ul>

<h3>Program</h3>

<p>A program expresses a computation. (A computation is any type of arithmetic or non-arithmetic calculation that is
well-defined).</p>

<p>A program is a sequence of expressions (and/or statements too, but let's keep it simple here).</p>

<ul>
<li><code>1 + 1</code> is an expression, but also a program which expresses the computation of adding 1 to 1.</li>
</ul>

<h3>Type - another perspective</h3>

<p>Types define the rules for combining expressions. The types define how the expressions can be combined, by applying
operations to them. For this reason, operations are also called members of types.</p>

<p>For instance, the && operation (and) is available on the type Boolean, and it expects another Boolean value on its
right-hand side. We say that the type Boolean has a member named && (and), which takes another Boolean value as a
parameter.</p>

<p>If you try to apply an operation to an expression,
whose type does not provide such an operation, it's an error.</p>

<h2>Domain Modelling</h2>

<p>Finding the <em>right</em> level of abstraction is more important than the best level of abstraction.</p>

<p>For example, in a problem involving doors and windows and facades, if the domain is constrained to only deal with surface area, then modelling the doors and windows and facade in terms of <strong>Rectangle</strong> is the right level of abstraction instead of modelling them as Door, Window, and Facade respectively.</p>

<h2>Functions and methods</h2>

<p>A function is a value in Scala, while a method is not. So the former can be passed as a parameter of a function or a method, and can be returned as a value. Method cannot do any of those.</p>

<p>A function is a value in Scala. All values are objects in Scala. An object can have methods. So a function in Scala can have methods.</p>

<p>Any function in Scala has a default <code>apply</code> method. <code>inc(1)</code> is a shorthand for <code>inc.apply(1)</code></p>

<h2>Collections</h2>

<p>Operations on collections can be classified into:</p>

<ul>
<li>construct ops (<code>::</code>, <code>+:</code>, <code>:+</code>, <code>+</code>, <code>++</code>;</li>
<li>query ops (<code>size</code>, <code>empty</code>, <code>head</code>, <code>tail</code>, <code>find</code>, <code>filter</code>); and</li>
<li>transform ops (<code>map</code>, <code>fold</code>)</li>
</ul>

<p>A list of immutable construction ops</p>
<ul>
<li><code>::</code> to prepend to a <code>List</code>. <code>1 :: List.empty</code></li>
<li><code>+:</code> to prepend to a <code>Sequence</code> collection, including <code>List</code>. <code>1 +: mutable.ArrayBuffer(2, 3)</code></li>
<li><code>:+</code> to append to a <code>Sequence</code> collection</li>
<li><code>+</code> to add a (key, value) tuple to a <code>Map</code></li>
<li><code>++</code> constructs a new collection out of two collections. <code>Map((1, "1"), (2, "2")) ++ Map((4, "4"))</code></li>
</ul>

<p>A list of mutable construction ops</p>
<ul>
<li><code>+=:</code> to prepend to a <code>Sequence</code> collection</li>
<li><code>+=</code> to append to a <code>Sequence</code> collection</li>
<li><code>++=</code>concatenates two collections, mutates the first one.</li>
</ul>

<h3>List</h3>

<p>A list is constructed from right to left:</p>

<pre><code>1 :: 2 :: 3 :: Nil</code></pre>

<h2>Option</h2>

<p>Option is actually a collection of zero or one element.</p>

<p>This explains why Option type has a <code>map</code> or <code>filter</code> operations even in OCaml.</p>

<p>No indexed access (<code>opt(0)</code>) though, understandably.</p>